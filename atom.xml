<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[武兵的技术博客]]></title>
  <subtitle><![CDATA[不积跬步，无以至千里]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://wubinge.github.io/"/>
  <updated>2016-01-04T14:15:30.328Z</updated>
  <id>http://wubinge.github.io/</id>
  
  <author>
    <name><![CDATA[bing]]></name>
    <email><![CDATA[bing.wu566@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[使用十六进制色值]]></title>
    <link href="http://wubinge.github.io/2015/07/07/%E4%BD%BF%E7%94%A8%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E8%89%B2%E5%80%BC/"/>
    <id>http://wubinge.github.io/2015/07/07/使用十六进制色值/</id>
    <published>2015-07-07T11:45:11.000Z</published>
    <updated>2015-07-07T12:31:37.000Z</updated>
    <content type="html"><![CDATA[<h3 id="前言">前言</h3>
<p>在做界面开发中，遇到颜色相关的视图，美术会在设计图标注一个色值。一般给的是十六进制的RGB值。可以使用代码解析色值，转化为UIColor实例；也可以在IB中直接设置颜色。</p>
<h3 id="代码使用Hex色值">代码使用Hex色值</h3>
<p>我们通常将十六进制色值转化为red、green和blue三个色值参数，使用UIColor的相关方法来接收参数，生成需要的UIColor实例。</p>
<ul>
<li>解析NSInteger十六进制色值,可以写成Macro。   </li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[UIColor colorWithRed:((<span class="built_in">float</span>)((rgbValue & <span class="number">0xFF0000</span>) &gt;&gt; <span class="number">16</span>))/<span class="number">255.0</span> green:((<span class="built_in">float</span>)((rgbValue & <span class="number">0xFF00</span>) &gt;&gt; <span class="number">8</span>))/<span class="number">255.0</span> blue:((<span class="built_in">float</span>)(rgbValue & <span class="number">0xFF</span>))/<span class="number">255.0</span> alpha:<span class="number">1.0</span>]</div></pre></td></tr></table></figure>

<ul>
<li>解析NSString类型十六进制色值<br>主要利用NSScaner的来实现，github上有一个<a href="https://github.com/mRs-/HexColors" target="_blank" rel="external">开源库</a>。</li>
</ul>
<h3 id="在IB中使用Hex色值">在IB中使用Hex色值</h3>
<p>通常我们在IB中的取色器无法使用Hex色值来设置颜色。<br>现在可以使用<a href="http://wafflesoftware.net/hexpicker/" target="_blank" rel="external">HexColorPicker</a>来实现这个功能。<br>下载安装包之后，解压并将其中的HexColorPicker.colorPicker文件拷贝到~/Library/ColorPickers目录里(没有ColorPickers则新建一个)。重新启动Xcode，IB的取色器是这样子的。带#tab页中输入Hex色值即可设置需要的颜色。  </p>
<p><img src="http://7xic7r.com1.z0.glb.clouddn.com/HexClor.png" align="center"></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="前言">前言</h3>
<p>在做界面开发中，遇到颜色相关的视图，美术会在设计图标注一个色值。一般给的是十六进制的RGB值。可以使用代码解析色值，转化为UIColor实例；也可以在IB中直接设置颜色。</p>
<h3 id="代码使用Hex色值">代码使用Hex色]]>
    </summary>
    
      <category term="工具方法" scheme="http://wubinge.github.io/categories/%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 9.0新特性]]></title>
    <link href="http://wubinge.github.io/2015/07/07/ios-9-0%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://wubinge.github.io/2015/07/07/ios-9-0新特性/</id>
    <published>2015-07-07T07:46:28.000Z</published>
    <updated>2015-07-07T12:32:46.000Z</updated>
    <content type="html"><![CDATA[<h5 id="App_Transport_Security">App Transport Security</h5>
<p>下载xcode7.0 beta版，运行app发现所有的网络请求都是失败的。<br>erro信息:<br>The resource could not be loaded because the App Transport Security policy requires the use of a secure connection</p>
<p>iOS9.0引入了App Transport Security的特性，要求在app的网络通讯必须使用安全的HTTPS协议。而我们的app使用的是http协议。<br>短时间内更换成HTTPS协议是不现实的，临时的解决办法:  </p>
<ul>
<li>Info.plist中添加行NSAppTransportSecurity，类型为NSDictionary.</li>
<li>NSAppTransportSecurity下添加bool类型的NSAllowsArbitraryLoads,值为YES.</li>
</ul>
<p>新的app要使用HTTPS协议来开发，旧的APP在时间充足的条件下最好更换协议。现在移动互联网越来越普及，对应的安全问题需要极其重视，特别是涉及个人隐私和支付的app。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h5 id="App_Transport_Security">App Transport Security</h5>
<p>下载xcode7.0 beta版，运行app发现所有的网络请求都是失败的。<br>erro信息:<br>The resource could not be]]>
    </summary>
    
      <category term="iOS应用程序开发" scheme="http://wubinge.github.io/categories/iOS%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac OS X开启NTFS格式存储的写权限]]></title>
    <link href="http://wubinge.github.io/2015/06/14/Mac-OS-X%E5%BC%80%E5%90%AFNTFS%E6%A0%BC%E5%BC%8F%E5%AD%98%E5%82%A8%E7%9A%84%E5%86%99%E6%9D%83%E9%99%90/"/>
    <id>http://wubinge.github.io/2015/06/14/Mac-OS-X开启NTFS格式存储的写权限/</id>
    <published>2015-06-14T13:14:01.000Z</published>
    <updated>2015-06-14T15:00:19.000Z</updated>
    <content type="html"><![CDATA[<h3 id="前言">前言</h3>
<p>我的移动硬盘分了三个区，格式分别为：Mac OS 扩展（日志式）、FAT32和NTFS。在Mac OS和Windows之间共享文件会使用FAT32和NTFS。但是对于容量大于4G的文件，FAT32无法写入，而NTFS在Mac OS无法写入数据，需要想办法实现在Mac OS上写入NTFS的功能。</p>
<h3 id="开启写入NTFS功能">开启写入NTFS功能</h3>
<p>有很多第三方软件可以实现写入NTFS格式存储。但这种方式太麻烦，这里介绍一种简单的方式。<br>在/etc目录创建文件：  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">sudo</span> vim /etc/fstab</div></pre></td></tr></table></figure>


<p>写入内容：  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LABEL=ntfsName  <span class="literal">none</span>    ntfs    rw,<span class="literal">auto</span>,nobrowse</div></pre></td></tr></table></figure>


<p>ntfsName是我们希望开启写入权限的NTFS格式磁盘或分区的名字,就是显示在Finder或者Desktop的名字，这样就可以对ntfsName分区进行写入操作。<br>需要注意的是，再次插入存储设备，我们找不到ntfsName的盘符以及图标。它被放在隐藏目录/Volumes里面。<br>如果不想每次都使用终端访问，那么将该目录链接到桌面即可：  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">sudo</span> ln <span class="operator">-s</span> /Volumes ~/Desktop/Volumes</div></pre></td></tr></table></figure>


<p>如果不想再支持写入NTFS，删除/etc/fstab即可。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="前言">前言</h3>
<p>我的移动硬盘分了三个区，格式分别为：Mac OS 扩展（日志式）、FAT32和NTFS。在Mac OS和Windows之间共享文件会使用FAT32和NTFS。但是对于容量大于4G的文件，FAT32无法写入，而NTFS在Mac OS无法]]>
    </summary>
    
      <category term="工具方法" scheme="http://wubinge.github.io/categories/%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[xcode包管理工具Alcatraz]]></title>
    <link href="http://wubinge.github.io/2015/04/27/xcode%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <id>http://wubinge.github.io/2015/04/27/xcode包管理工具/</id>
    <published>2015-04-27T12:00:48.000Z</published>
    <updated>2015-04-28T06:45:01.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7xic7r.com1.z0.glb.clouddn.com/alcatraz屏幕快照 2015-04-27 20.15.03.png" width="500"><br></p>
<h3 id="简介">简介</h3>
<p>Alcatraz是专为xcode设计的开源包管理工具，开发者可以用它自动的搜索、安装所需要的xcode插件、颜色方案和模板，完全摒弃了手动拷贝文件来安装xcode包的方式。Alcatraz的使用体验非常友好，就像是xcode原生的功能。</p>
<h3 id="安装">安装</h3>
<p>Alcatraz的安装非常方便快速，打开终端输入以下命令：  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -fsSL http<span class="variable">s:</span>//raw.githubusercontent.<span class="keyword">com</span>/supermarin/Alcatraz/master/Scripts/install.<span class="keyword">sh</span> | <span class="keyword">sh</span></div></pre></td></tr></table></figure>


<p>当前支持OSX 10.9和Xcode 5以上版本<br>xcode的插件目录是  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">~<span class="regexp">/Library/</span>Application Support<span class="regexp">/Developer/</span>Shared<span class="regexp">/Xcode/</span>Plug-ins</div></pre></td></tr></table></figure>


<p>没有安装过xcode插件，这个目录是不存在的。<br>如果上面的安装命令失败，可以手动下载<a href="https://github.com/supermarin/Alcatraz/releases/download/1.1.2/Alcatraz.tar.gz" target="_blank" rel="external">Alcatraz</a>解压后放入插件目录，插件目录可以手动创建。Alcatraz本质上也是xcode的一个插件。</p>
<h3 id="卸载">卸载</h3>
<p>删除Alcatraz</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm -rf ~<span class="regexp">/Library/</span>Application\ Support<span class="regexp">/Developer/</span>Shared<span class="regexp">/Xcode/</span>Plug-ins<span class="regexp">/Alcatraz.xcplugin</span></div></pre></td></tr></table></figure>

<p>移除缓存</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm -rf ~<span class="regexp">/Library/</span><span class="constant">Application</span>\ <span class="constant">Support</span>/<span class="constant">Alcatraz</span></div></pre></td></tr></table></figure>

<h3 id="使用">使用</h3>
<p>使用非常方便，Xcode-&gt;Menu-&gt;Window-&gt;Package Manager  </p>
<p><img src="http://7xic7r.com1.z0.glb.clouddn.com/alcatraz1.png" width="500">  </p>
<p>alcatraz界面图，包含插件、颜色方案和模板。直接搜索需要的插件并下载，删除也非常方便。 </p>
<p><img src="http://7xic7r.com1.z0.glb.clouddn.com/alcatraz2.png" width="500"></p>
<p><a href="http://www.cocoachina.com/industry/20130918/7022.html" target="_blank" rel="external">这篇文章</a>列出一些提高xcode工作效率的插件。使用alcatraz直接搜索下载安装即可使用。 </p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7xic7r.com1.z0.glb.clouddn.com/alcatraz屏幕快照 2015-04-27 20.15.03.png" width="500"><br></p>
<h3 id="简介">简介</h3>
<p>Alcatra]]>
    </summary>
    
      <category term="工具方法" scheme="http://wubinge.github.io/categories/%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS音频开发之音乐播放器II]]></title>
    <link href="http://wubinge.github.io/2015/04/20/iOS%E9%9F%B3%E9%A2%91%E5%BC%80%E5%8F%91%E4%B9%8B%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8II/"/>
    <id>http://wubinge.github.io/2015/04/20/iOS音频开发之音乐播放器II/</id>
    <published>2015-04-20T08:20:09.000Z</published>
    <updated>2015-06-05T09:18:04.000Z</updated>
    <content type="html"><![CDATA[<h3 id="后台播放">后台播放</h3>
<p>作为一款音乐播放器，我们希望APP在进入后台或者lock screen的时候仍然可以播放音乐。由于iOS的多任务机制的限制，在APP进入后台时，很快就被系统挂起。因此需要做接下来的两件事情。</p>
<ul>
<li>Background Mode</li>
</ul>
<p>为了满足某些APP后台运行的需求，iOS允许具有某些功能的APP设置Background Mode来达到后台运行的目的。音频类的可以在info.plist中添加Required background modes键，值设置为App plays audio或者如图所示勾选：<br><img src="http://7xic7r.com1.z0.glb.clouddn.com/image/bgmodeA7EA71ED-3165-4B02-8D99-13C1944F7821.png" width="500" height="100" alt="Background Modes" align="center"><br></p>
<ul>
<li>配置AVAudiosession</li>
</ul>
<p>AVAudiosession是AVFoundation框架提供的一个单例类，可以用来为我们的APP设置一个合适的音频环境。通过对他进行配置，我们可以为自己的音乐播放APP设置合适的特征。<br>AVAudiosession有一个category属性，默认值是AVAudioSessionCategorySoloAmbient。该属性值的特征如下：</p>
<p>1、(设置正确的Background Mode)后台以及锁屏状态停止播放。</p>
<p>2、开启静音开关，音乐静音。</p>
<p>3、可以和其他APP的音频进行混音。意即打开本APP(开启AVAudiosession)，其他APP的声音不会停止。SDK的注释是这样的</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/*  Use this category <span class="keyword">for</span> background sounds such <span class="keyword">as</span> rain, car engine noise, etc.  </div><div class="line"> Mixes <span class="keyword">with</span> other music. */</div><div class="line">AVF_EXPORT NSString *<span class="keyword">const</span> AVAudioSessionCategoryAmbient;</div></pre></td></tr></table></figure>

<p>因此可以用在游戏里面的背景音效播放。比如希望在后台播放喜欢的音乐同时玩一款游戏，我们肯定不希望打开游戏时，后台播放的背景音乐停止播放。</p>
<p>显然这个默认值对于我们的音乐播放器是不合适的。我们应该使用</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">AVAudioSession * avSession = [AVAudioSession sharedInstance];</div><div class="line">[avSession  setCategory:AVAudioSessionCategoryPlayback <span class="built_in">error</span>:<span class="keyword">nil</span>];</div></pre></td></tr></table></figure>

<p>没错，就是AVAudioSessionCategoryPlayback，它的特征完全符合我们对于音乐播放器的需要：</p>
<p>1、(设置正确的Background Mode)后台以及锁屏继续播放。</p>
<p>2、开启静音开关，不影响音频音量。</p>
<p>3、默认禁止混音(nonmixable)。意即开启打开本APP(开启AVAudiosession)，其他同样是采用nonmixable类别的audio session将停止(无法使得mixable的audio session停止)。可以使用下面的方法改变这个特性，但是对于一款音乐播放器，mixable是没有必要的。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[avSession  setCategory:AVAudioSessionCategoryPlayback </div><div class="line"></div><div class="line">withOptions:AVAudioSessionCategoryOptionMixWithOthers <span class="built_in">error</span>:<span class="keyword">nil</span>];</div></pre></td></tr></table></figure>

<p>至此我们就实现了音频后台播放。</p>
<p>关于混音再说一点，除了游戏背景音乐适合采用混音模式外，优先级比较高的音频功能，例如实现了定时播放音频功能的闹钟或者提醒类应用，也可以采用混音模式。这样即便用户在听歌也不会错过重要的提醒。</p>
<p>我们最近开发的基于提醒的社交APP <a href="https://itunes.apple.com/CN/app/id938161536" title="title" target="_blank" rel="external">神多多闹钟</a> 就是使用AVAudioplayer的playAtTime达到定时播放指定音频的目的。并且AVAudioSession采用的是混音模式。</p>
<h3 id="音频中断">音频中断</h3>
<p>手机上不止我们一款APP，在听歌的时候，如果有人给我们打电话；或者之前定的一个闹钟到时间了；或者使用了siri功能。这些会使用手机音频的应用，就会跟我们的APP音频起冲突。称作音频中断。<br>iOS系统的音频服务优先级高于第三方APP。当有电话进入、系统闹钟响起，都会导致第三方APP的audiosession中断。 以来电为例，展示音频中断的流程:   </p>
<p><img src="http://7xic7r.com1.z0.glb.clouddn.com/audio_session_interrupted.png" width="500" height="300" alt="Background Modes" align="center"><br></p>
<p>可以看到，来电话时，APP的audiosession被设置系统为inactive状态。当用户忽略来电，系统自动将其设置为active。在中断开始和结束时，需要APP做出对应的行为。例如开始/暂停播放以及更新界面。<br>通过注册观察者来获取AVAudioSessionInterruptionNotification事件的通知来响应中断的开始和结束。  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr_selector">[[NSNotificationCenter defaultCenter]</span> <span class="tag">addObserver</span><span class="pseudo">:self</span> <span class="tag">selector</span>:<span class="at_rule">@<span class="keyword">selector(interruptionNotificationCallback:)</span> name:AVAudioSessionInterruptionNotification object:nil]</span>;</div></pre></td></tr></table></figure>


<p>在interruptionNotificationCallback通过判断AudioSessionInterruptionType来分别处理interruption begin 和 interruption end.  </p>
<h3 id="远程控制">远程控制</h3>
<p>设想以下的使用场景，用户用我们的APP在后台听着音乐，刷着微博或者微信。这时候用户希望调节音量，快进快退或者切换歌曲。除了重新打开APP来操作外，还可以在iOS的Control Center中进行这些操作。<br>Control Center允许用户随处快速访问常用的设置和APP，甚至在锁屏界面也可以访问。在手机屏幕底部上滑即可唤出Control Center。<br><img src="http://7xic7r.com1.z0.glb.clouddn.com/control_center.png" width="200" height="300" alt="Background Modes" align="center"><br><br>iOS7.1以后，Media Player framework 加入了MPRemoteCommandCenter这个类。使用block类实现远程控制回调。在这里我使用MPRemoteCommandCenter。iOS7.1之前，需要在UIApplication中实现remoteControlReceivedWithEvent来处理。<br>要让APP支持RemoteControl,我们需要用到MPRemoteCommandCenter单例类。它提供了处理 remote control events所需要的对象。它的属性中包括了众多MPRemoteCommand类对象，代表着iOS所支持的不同类型的remote control evnt。为MPRemoteCommand对象添加target和action来响应其控制事件。  </p>
<h5 id="获取MPRemoteCommandCenter对象">获取MPRemoteCommandCenter对象</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">MPRemoteCommandCenter *commandCenter </span>=<span class="string"> [MPRemoteCommandCenter sharedCommandCenter];</span></div></pre></td></tr></table></figure>

<h6 id="播放控制">播放控制</h6>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[commandCenter.playCommand <span class="symbol">addTarget:</span><span class="keyword">self</span> <span class="symbol">action:</span><span class="variable">@selector</span>(<span class="symbol">didReceivePlayCommand:</span>)];</div><div class="line">[commandCenter.pauseCommand <span class="symbol">addTarget:</span><span class="keyword">self</span> <span class="symbol">action:</span><span class="variable">@selector</span>(<span class="symbol">didReceivePauseCommand:</span>)];</div></pre></td></tr></table></figure>

<h6 id="切换歌曲">切换歌曲</h6>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[commandCenter.nextTrackCommand <span class="symbol">addTarget:</span><span class="keyword">self</span> <span class="symbol">action:</span><span class="variable">@selector</span>(didReceiveNextTrackCommand)];</div><div class="line">[commandCenter.previousTrackCommand <span class="symbol">addTarget:</span><span class="keyword">self</span> <span class="symbol">action:</span><span class="variable">@selector</span>(didReceivePreviousTrackCommand)];</div></pre></td></tr></table></figure>

<p>这些可以满足一般的播放器对于RemoteControl的要求。<br>MPRemoteCommandCenter也提供了一些相对精细化的控制属性。例如改变播放速率、快进快退、跳转到固定时间点播放等等,<a href="!https://developer.apple.com/library/ios/documentation/MediaPlayer/Reference/MPRemoteCommandCenter_Ref/#//apple_ref/occ/instp/MPRemoteCommandCenter/skipBackwardCommand">这里</a>可以看到更详细的介绍。</p>
<h3 id="锁频界面显示歌曲信息">锁频界面显示歌曲信息</h3>
<p>为了在锁屏界面和控制中心显示当前歌曲的信息，需要用到Media Player Framework的MPNowPlayingInfoCenter类。<br>这是一个单例类，用法非常简单，只需为其nowPlayingInfo属性设置适当的值即可。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[MPNowPlayingInfoCenter defaultCenter] setNowPlayingInfo:songInfo]</div></pre></td></tr></table></figure>

<p>songInfo是一个NSDictionary的对象，里面包含着希望显示的歌曲信息。<br>该功能的关键就是创建这个NSDictionary的对象。<br>1、相关key定义在MPMediaItem.h中，部分常用key如下：  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">MP_EXTERN <span class="built_in">NSString</span> * <span class="keyword">const</span> MPMediaItemPropertyArtwork; <span class="comment">//歌曲封面</span></div><div class="line">MP_EXTERN <span class="built_in">NSString</span> * <span class="keyword">const</span> MPMediaItemPropertyTitle;   <span class="comment">//歌名</span></div><div class="line">MP_EXTERN <span class="built_in">NSString</span> * <span class="keyword">const</span> MPMediaItemPropertyAlbumTitle;  <span class="comment">//专辑名</span></div><div class="line">MP_EXTERN <span class="built_in">NSString</span> * <span class="keyword">const</span> MPMediaItemPropertyArtist;  <span class="comment">//歌手</span></div></pre></td></tr></table></figure>

<p>2、valu的获取<br>根据歌曲来源的不同，这里有两种歌曲信息的获取方式：  </p>
<ul>
<li><p>itunes Library<br>通过MPMediaPickerController获取itunes Library的歌曲。很容易就获取到歌曲的MPMediaItem。MPMediaItem包   含我们所需要的歌曲信息。MPMediaPickerController和MPMediaItem是Media Player Framework的内容。</p>
</li>
<li><p>App内歌曲</p>
</li>
</ul>
<p>如果是App内的歌曲，根据歌曲文件路径，获取AVMetadataItem。简单给出获取方法：  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURL</span> * url = [<span class="built_in">NSURL</span> fileURLWithPath:audio];</div><div class="line">AVURLAsset * asset = [AVURLAsset assetWithURL:url];</div><div class="line"><span class="built_in">NSMutableDictionary</span> *songInfo = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</div><div class="line"><span class="built_in">NSArray</span> * formats = [asset availableMetadataFormats];</div><div class="line"><span class="keyword">for</span>(<span class="built_in">NSString</span> * format <span class="keyword">in</span> formats)</div><div class="line">{</div><div class="line">   <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,format);</div><div class="line">   <span class="built_in">NSArray</span> * items = [asset metadataForFormat:format];</div><div class="line">   <span class="keyword">for</span> (AVMetadataItem* item <span class="keyword">in</span> items)</div><div class="line">   {</div><div class="line">       <span class="built_in">NSLog</span>(<span class="string">@"%@\n"</span>,item<span class="variable">.commonKey</span>);</div><div class="line">       </div><div class="line">       <span class="keyword">if</span> ([item<span class="variable">.commonKey</span> isEqualToString:<span class="string">@"artwork"</span>])</div><div class="line">       {</div><div class="line">           <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,item<span class="variable">.dataType</span>);</div><div class="line">           <span class="built_in">UIImage</span>* image = [<span class="built_in">UIImage</span> imageWithData:(NSData*)item<span class="variable">.value</span>];</div><div class="line">           MPMediaItemArtwork *albumArt = [[MPMediaItemArtwork alloc] initWithImage:image];</div><div class="line">           [songInfo setObject:albumArt forKey:MPMediaItemPropertyArtwork];</div><div class="line">       }<span class="keyword">else</span> <span class="keyword">if</span> ([item<span class="variable">.commonKey</span> isEqualToString:<span class="string">@"title"</span>])</div><div class="line">       {</div><div class="line">           [songInfo setObject:item<span class="variable">.value</span> forKey:MPMediaItemPropertyTitle];</div><div class="line">       }</div><div class="line">       <span class="keyword">else</span> <span class="keyword">if</span> ([item<span class="variable">.commonKey</span> isEqualToString:<span class="string">@"albumName"</span>])</div><div class="line">       {</div><div class="line">           [songInfo setObject:item<span class="variable">.value</span> forKey:MPMediaItemPropertyAlbumTitle];</div><div class="line">       }</div><div class="line">       <span class="keyword">else</span> <span class="keyword">if</span> ([item<span class="variable">.commonKey</span> isEqualToString:<span class="string">@"artist"</span>])</div><div class="line">       {</div><div class="line">           [songInfo setObject:item<span class="variable">.value</span> forKey:MPMediaItemPropertyArtist];</div><div class="line">       }</div><div class="line">   }</div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="特别注意">特别注意</h4>
<p>需要特别注意的是MPNowPlayingInfoPropertyPlaybackRate 和MPNowPlayingInfoPropertyElapsedPlaybackTime。前者表示播放速率，后者表示已播放时间，即上图中进度条左边的时间。MPNowPlayingInfoPropertyElapsedPlaybackTime不需要我们来刷新，而是自动地根据前一个时间和播放速率来计算。<br>因此当歌曲暂停时，其实该值还是在增加。为了保证该值的精确，需要在暂停和重新开始播放时，重新设置MPNowPlayingInfoPropertyPlaybackRate的值。</p>
<h3 id="代码">代码</h3>
<p>有一个相关的<a href="https://github.com/wubingwell/WBAudioPlayer/tree/master/WBAudioPlayer" target="_blank" rel="external">demo</a>放在github上面，后面会为这个demo更新一个apple watch app。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="后台播放">后台播放</h3>
<p>作为一款音乐播放器，我们希望APP在进入后台或者lock screen的时候仍然可以播放音乐。由于iOS的多任务机制的限制，在APP进入后台时，很快就被系统挂起。因此需要做接下来的两件事情。</p>
<ul>
<li>Back]]>
    </summary>
    
      <category term="iOS应用程序开发" scheme="http://wubinge.github.io/categories/iOS%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS音频开发之音乐播放器I]]></title>
    <link href="http://wubinge.github.io/2015/03/30/iOS%E9%9F%B3%E9%A2%91%E5%BC%80%E5%8F%91%E4%B9%8B%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8I/"/>
    <id>http://wubinge.github.io/2015/03/30/iOS音频开发之音乐播放器I/</id>
    <published>2015-03-30T12:47:09.000Z</published>
    <updated>2015-06-05T09:17:58.000Z</updated>
    <content type="html"><![CDATA[<h4 id="前言">前言</h4>
<p>用两篇博文来介绍一款本地音乐播放器的功能开发。<br>围绕一个AVAudioPlayer的本地播放器来介绍音频播放器开发的主要功能实现。  例如后台播放、中断处理以及锁屏等。有一个相关的<a href="https://github.com/wubingwell/WBAudioPlayer" target="_blank" rel="external">demo</a>放在github上面。<br>AVAudioPlayer适用于播放本地音频文件和音频数据。简单展示音频信息以及控制播放，而不需要对音频数据进行自定义的处理比如编解码等，那么使用AVAudioPlayer即可。<br>AVAudioPlayer来自于MediaLayer的AVFoundation.framework。 AVFoundation提供一系列Object-C接口实现对音视频和图片的播放、录制和处理功能。  </p>
<hr>
<h4 id="初始化">初始化</h4>
<p>初始化很简单，这里简单列一下。首先要导入AVFoundation.framework<br>可以使用本地NSURL和内存数据NSData来初始化一个AVAudioPlayer的实例。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURL</span> * url = [<span class="built_in">NSURL</span> fileURLWithPath:audio];</div><div class="line">AVAudioPlayer * player = [[AVAudioPlayer alloc] initWithContentsOfURL:url error:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>

<h3 id="相关属性">相关属性</h3>
<p>1、循环播放次数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="at_rule">@<span class="keyword">property</span> NSInteger numberOfLoops</span>;</div></pre></td></tr></table></figure>

<p>该属性值为0代表播放一次结束；1代表播放两次；以此类推。</p>
<hr>
<p>2、音频时长</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">readonly</span>) <span class="built_in">NSTimeInterval</span> duration; <span class="comment">/* the duration of the sound. */</span></div></pre></td></tr></table></figure>

<p>单位是秒，可以用来显示以及计算当前播放的进度。</p>
<hr>
<p>3、当前时间</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="at_rule">@<span class="keyword">property</span> NSTimeInterval currentTime</span>;</div></pre></td></tr></table></figure>

<p>单位是秒，表示当前的播放位置;对其赋值时，则表示播放的起始位置。<br>通过改变该属性值可以实现快进快退的seek功能。</p>
<hr>
<p>4、音量</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property <span class="keyword">float</span> <span class="shader"><span class="keyword">volume</span>;</span></div></pre></td></tr></table></figure>

<hr>
<p>5、播放速度</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="at_rule">@<span class="keyword">property</span> BOOL enableRate <span class="function">NS_AVAILABLE</span>(<span class="number">10</span>_8, <span class="number">5</span>_0)</span>;</div><div class="line"><span class="at_rule">@<span class="keyword">property</span> float rate</span></div></pre></td></tr></table></figure>

<p>必须设置enableRate = YES之后，设置rate的值才有效果。0.5表示一半速度，1.0表示正常速度，2.0表示两倍速度。</p>
<hr>
<p>6、当前设备时间</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="at_rule">@<span class="keyword">property(readonly)</span> NSTimeInterval deviceCurrentTime <span class="function">NS_AVAILABLE</span>(<span class="number">10</span>_7, <span class="number">4</span>_0)</span>;</div></pre></td></tr></table></figure>

<p>代表音频输出设备的连续工作时间。只要有一个播放器存在，无论其处于播放、停止还是暂停状态，该属性的值都连续增长。以AVAudioPlayer为例，当player实例置空时，该属性值为0。<br>当使用playAtTime时用到该属性。</p>
<hr>
<h3 id="重要方法">重要方法</h3>
<p>1、播放</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-<span class="ruby"> (<span class="constant">BOOL</span>)prepareToPlay;	</span></div><div class="line">-<span class="ruby"> (<span class="constant">BOOL</span>)play;</span></div></pre></td></tr></table></figure>

<p>在play之前调用prepareToPlay方法，预加载音频数据缓冲以及获取播放所需要的音频硬件。从而在调用play进行播放时减少延迟时间。尤其是在audio interruption结束后需要resume audio时，必须先调用prepareToPlay，否则无法重新播放。</p>
<hr>
<p>2、在未来某个时间开始播放</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(<span class="variable">BOOL</span>)</span>playAtTime:<span class="params">(<span class="variable">NSTimeInterval</span>)</span>time NS_AVAILABLE<span class="params">(<span class="number">10</span>_7, <span class="number">4</span>_0)</span></span></div></pre></td></tr></table></figure>

<p>该方法允许在未来的某个时间点播放音频。参数time必须是基于deviceCurrentTime并且比其大的绝对时间。例如如果希望在距离当前时间点20s后播放音频:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">[player playAtTime:player.deviceCurrentTime+20]</span><span class="comment">;</span></div></pre></td></tr></table></figure>

<p>这里的deviceCurrentTime代表的是音频输出设备的NOW时间点。该方法可以代替UILocalNotification实现闹钟的功能，如果你希望在闹钟时间播放高度自定义的音频。</p>
<h3 id="AVAudioPlayerDelegate">AVAudioPlayerDelegate</h3>
<p>AVAudioPlayerDelegate定义了播放状态的协议方法，实现这些方法可以方便地响应播放器的状态。</p>
<p>1、播放结束</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(void)</span>audioPlayerDidFinishPlaying:<span class="params">(<span class="variable">AVAudioPlayer</span> *)</span>player successfully:<span class="params">(<span class="variable">BOOL</span>)</span>flag;</span></div></pre></td></tr></table></figure>

<p>音频播放结束时会调用这个方法，可以在里面做切歌以及更新UI等操作。</p>
<p>2、解码过程中出现错误</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(void)</span>audioPlayerDecodeErrorDidOccur:<span class="params">(<span class="variable">AVAudioPlayer</span> *)</span>player error:<span class="params">(<span class="variable">NSError</span> *)</span>error;</span></div></pre></td></tr></table></figure>

<p>播放过程中如果解码出错，会调用这个方法。在此给出用户相关的UI提示。</p>
<p>3、中断相关</p>
<p>AVAudioPlayerDelegate提供了处理中断的协议方法，播放过程中如果有电话、系统闹钟等会中断当前的音频播放。中断开始和结束后，需要进行相应的处理，这几个方法在iOS8.0已经过期，可以使用AVAudiosession的中断通知来实现该功能。<br>对于音频的中断处理，见<a href="http://wubingwell.github.io/2015/04/20/iOS%E9%9F%B3%E9%A2%91%E5%BC%80%E5%8F%91%E4%B9%8B%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8II/" target="_blank" rel="external">另外一篇</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="前言">前言</h4>
<p>用两篇博文来介绍一款本地音乐播放器的功能开发。<br>围绕一个AVAudioPlayer的本地播放器来介绍音频播放器开发的主要功能实现。  例如后台播放、中断处理以及锁屏等。有一个相关的<a href="https://github.]]>
    </summary>
    
      <category term="iOS应用程序开发" scheme="http://wubinge.github.io/categories/iOS%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[]]></title>
    <link href="http://wubinge.github.io/2015/03/25/UINavigationController%E5%9C%A8ios7%E7%9A%84%E5%8F%98%E5%8C%96/"/>
    <id>http://wubinge.github.io/2015/03/25/UINavigationController在ios7的变化/</id>
    <published>2015-03-25T08:20:00.000Z</published>
    <updated>2016-01-04T14:15:12.000Z</updated>
    <content type="html"><![CDATA[<h3 id="问题">问题</h3>
<hr>
<p>   最近做了个关于UINavigationController的demo，遇到一个问题，又引出更多问题，记录一下。 在ios7中，UINavigationController发生了很大的变化，特别是导航栏。<br>   先用一些代码，描述问题：<br>  1、添加导航控制器和视图控制器： </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</div><div class="line">{</div><div class="line">    <span class="keyword">self</span><span class="variable">.window</span> = [[<span class="built_in">UIWindow</span> alloc] initWithFrame:[[UIScreen mainScreen] bounds]];</div><div class="line">    <span class="keyword">self</span><span class="variable">.window</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> whiteColor];</div><div class="line">    [<span class="keyword">self</span><span class="variable">.window</span> makeKeyAndVisible];</div><div class="line">    MainViewController* mainController = [[MainViewController alloc] init];</div><div class="line">    <span class="built_in">UINavigationController</span>* nav = [[<span class="built_in">UINavigationController</span> alloc] initWithRootViewController:mainController];</div><div class="line">    <span class="keyword">self</span><span class="variable">.window</span><span class="variable">.rootViewController</span> = nav;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>；</div></pre></td></tr></table></figure>


<p>  2、MainViewController添加UILabel  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad</div><div class="line">{</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// Do any additional setup after loading the view from its nib.</span></div><div class="line">    <span class="built_in">UILabel</span>* label = [[<span class="built_in">UILabel</span> alloc] initWithFrame:CGRectMake(<span class="number">0</span>,<span class="number">0</span>, <span class="number">50</span>, <span class="number">50</span>)];</div><div class="line">    [label setText:<span class="string">@"test"</span>];</div><div class="line">    [label setBackgroundColor:[<span class="built_in">UIColor</span> redColor]];</div><div class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addSubview:label];</div><div class="line">}</div></pre></td></tr></table></figure>



<p>代码在ios6和ios7运行的效果如下：<br>ios6：  </p>
<p><img src="http://7xic7r.com1.z0.glb.clouddn.com/20140402202833140.png" width="500"><br></p>
<p>ios7：</p>
<p><img src="http://7xic7r.com1.z0.glb.clouddn.com/20140402202833140.png" width="500"><br>  </p>
<h3 id="描述">描述</h3>
<hr>
<p>self.view代表maincontroller的视图<br>问题出现了，很明显可以看出来，在ios7里面，self.view的内容延伸到了导航栏和状态栏的下面，并且可以模糊的看到。<br>首先我们来大概了解一下导航器的视图结构。用NSLog打印出状态栏、导航条和self.view以及self.view.superview的frame可以看出一些来。<br>这里以3.5屏幕为例  </p>
<h4 id="iOS6正常状态">iOS6正常状态</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">状态栏(<span class="number">0</span>,<span class="number">0</span>,<span class="number">320</span>,<span class="number">20</span>)   导航条(<span class="number">0</span>,<span class="number">20</span>,<span class="number">320</span>,<span class="number">44</span>)     self.<span class="keyword">view</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">320</span>,<span class="number">416</span>)   </div><div class="line">self.<span class="keyword">view</span>.superview(<span class="number">0</span>,<span class="number">64</span>,<span class="number">320</span>,<span class="number">416</span>)</div></pre></td></tr></table></figure>


<h4 id="iOS6隐藏状态栏">iOS6隐藏状态栏</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">状态栏(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)          导航条(<span class="number">0</span>,<span class="number">0</span>,<span class="number">320</span>,<span class="number">44</span>)self.<span class="keyword">view</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">320</span>,<span class="number">436</span>)     </div><div class="line">self.<span class="keyword">view</span>.superview(<span class="number">0</span>,<span class="number">44</span>,<span class="number">320</span>,<span class="number">436</span>)</div></pre></td></tr></table></figure>

<h4 id="iOS6隐藏导航栏">iOS6隐藏导航栏</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">状态栏(<span class="number">0</span>,<span class="number">0</span>,<span class="number">320</span>,<span class="number">20</span>)   导航条(<span class="number">0</span>,-<span class="number">24</span>,<span class="number">320</span>,<span class="number">44</span>)   self.<span class="keyword">view</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">320</span>,<span class="number">460</span>)     </div><div class="line">self.<span class="keyword">view</span>.superview(<span class="number">0</span>,<span class="number">20</span>,<span class="number">320</span>,<span class="number">460</span>)</div></pre></td></tr></table></figure>


<p>可以看出，状态栏、导航栏、self.view.superview在同一个坐标系内。<br>状态栏和导航栏的改变，会影响self.view.superview的变化。但是要注意的是，self.view的坐标始终不变，只是高度会随着superview而变化。<br>至于隐藏导航栏以后，为什么y坐标会变为-24，留出20的高度，推测作为状态栏的背景。</p>
<h5 id="iOS7正常状态">iOS7正常状态</h5>
<p>状态栏背景透明，导航栏半透明，导航栏的背景高度为64，frame(0,-20,320,64),Y方向多出的20点可以作为状态栏的背景。默认self.view延伸到屏幕顶部，被状态栏和导航栏覆盖。<strong>默认导航栏的 translucent = YES</strong>  此时各个元素的frame如下： </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">状态栏(<span class="number">0</span>,<span class="number">0</span>,<span class="number">320</span>,<span class="number">20</span>)    导航条(<span class="number">0</span>,<span class="number">20</span>,<span class="number">320</span>,<span class="number">44</span>)   self.<span class="keyword">view</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">320</span>,<span class="number">480</span>)     self.<span class="keyword">view</span>.superview(<span class="number">0</span>,<span class="number">0</span>,<span class="number">320</span>,<span class="number">480</span>)</div></pre></td></tr></table></figure>

<h4 id="iOS7隐藏状态栏">iOS7隐藏状态栏</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">状态栏(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)          导航条(<span class="number">0</span>,<span class="number">0</span>,<span class="number">320</span>,<span class="number">44</span>)     self.<span class="keyword">view</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">320</span>,<span class="number">480</span>)     self.<span class="keyword">view</span>.superview(<span class="number">0</span>,<span class="number">0</span>,<span class="number">320</span>,<span class="number">480</span>)</div></pre></td></tr></table></figure>

<h4 id="iOS7隐藏导航栏">iOS7隐藏导航栏</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">状态栏(<span class="number">0</span>,<span class="number">0</span>,<span class="number">320</span>,<span class="number">20</span>)   导航条(<span class="number">0</span>,-<span class="number">44</span>,<span class="number">320</span>,<span class="number">44</span>)   self.<span class="keyword">view</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">320</span>,<span class="number">480</span>)     self.<span class="keyword">view</span>.superview(<span class="number">0</span>,<span class="number">0</span>,<span class="number">320</span>,<span class="number">480</span>)</div></pre></td></tr></table></figure>

<p>可以看出，self.view.superview不会因为状态栏和导航栏的改变而发生变化，始终铺满整个屏幕，当然self.view也是铺满整个屏幕的。</p>
<h4 id="设置translucent_=_NO">设置translucent = NO</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">状态栏(<span class="number">0</span>,<span class="number">0</span>,<span class="number">320</span>,<span class="number">20</span>)    导航条(<span class="number">0</span>,<span class="number">20</span>,<span class="number">320</span>,<span class="number">44</span>)   self.<span class="keyword">view</span>(<span class="number">0</span>,<span class="number">64</span>,<span class="number">320</span>,<span class="number">416</span>)     self.<span class="keyword">view</span>.superview(<span class="number">0</span>,<span class="number">0</span>,<span class="number">320</span>,<span class="number">480</span>)</div></pre></td></tr></table></figure>

<p><strong><em>设置translucent=NO之后，self.view.superview依然铺满屏幕<br>self.view在状态栏和导航栏都可见的情况下，Y方向坐标是64<br>这是因为设置了导航栏的属性translucent=NO,所以self.view从导航栏下面开始平铺。</em></strong></p>
<h4 id="iOS7隐藏状态栏-1">iOS7隐藏状态栏</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">状态栏(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)      导航条(<span class="number">0</span>,<span class="number">0</span>,<span class="number">320</span>,<span class="number">44</span>)     self.<span class="keyword">view</span>(<span class="number">0</span>,<span class="number">44</span>,<span class="number">320</span>,<span class="number">436</span>)     self.<span class="keyword">view</span>.superview(<span class="number">0</span>,<span class="number">0</span>,<span class="number">320</span>,<span class="number">480</span>)</div></pre></td></tr></table></figure>

<p><strong><em>当状态栏隐藏，self.viewY坐标上移20点，高度增加20点</em></strong> </p>
<h4 id="iOS7隐藏导航栏-1">iOS7隐藏导航栏</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">状态栏(<span class="number">0</span>,<span class="number">0</span>,<span class="number">320</span>,<span class="number">20</span>)   导航条(<span class="number">0</span>,-<span class="number">44</span>,<span class="number">320</span>,<span class="number">44</span>)   self.<span class="keyword">view</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">320</span>,<span class="number">480</span>)      self.<span class="keyword">view</span>.superview(<span class="number">0</span>,<span class="number">0</span>,<span class="number">320</span>,<span class="number">480</span>)</div></pre></td></tr></table></figure>

<p><strong><em>隐藏了导航栏之后，translucent属性失去作用，self.view从屏幕左上角开始平铺，被状态栏覆盖了20点的高度</em></strong>  </p>
<h3 id="总结">总结</h3>
<hr>
<h4 id="iOS6">iOS6</h4>
<ul>
<li>状态栏20高度导航栏44高度  </li>
<li>self.view.superview的Y坐标和高度会随着状态栏和导航栏高度变化  </li>
<li>self.view坐标和宽度不变，高度会随着self.view.superview变化。self.view的子视图不会被状态条或者导航条遮盖。</li>
</ul>
<h4 id="iOS7">iOS7</h4>
<ul>
<li>状态栏背景透明，高度20  </li>
<li>导航栏背景半透明，坐标(0,-20,320,64)，Y轴方向多出的20点可以作为状态栏的背景，所以设置导航栏背景色，也能作为状态栏背景色  </li>
<li>因为状态栏和导航栏所在区域开放给开发者操作，所以self.view.superview从屏幕顶部开始平铺整个屏幕并且固定并不变。  </li>
<li>当导航栏显示且透明时，self.view的坐标(0,0)，当然也是平铺整个屏幕，延伸到导航栏和状态栏下面  </li>
<li>当导航栏显示但是不透明，self.view刚好在导航栏的下边界开始平铺，此时状态栏的隐藏会影响到导航栏和self.view的坐标和高度。  </li>
<li>导航栏隐藏，则透明属性不起作用，self.view坐标(0,0)，平铺整个屏幕，被状态栏遮盖20高度。</li>
</ul>
<h4 id="iOS7中设置self-view从导航栏下面显示的方法">iOS7中设置self.view从导航栏下面显示的方法</h4>
<h5 id="全局设置">全局设置</h5>
<ul>
<li>[navigationBar setTranslucent:NO]。设置导航栏不透明，对所有控制器视图有效果。导航栏不透明了，不会再让你延伸view了。  </li>
<li>[navigationBar setBackgroundImage:[UIImage imageNamed:@”image_background.png”] forBarMetrics:UIBarMetricsDefault];自定义导航栏背景图片，对所有控制器视图有效果。自定义背景，等于不透明，延伸了也看不到。   </li>
<li>iOS7 SDK中新增了一个设置背景图片的方法（setBackgroundImage:forBarPosition:barMetrics:），比原有的方法多了一个UIBarPosition枚举参数，用于设置背景图片拉伸的策略<br>UIBarPositionTopAttached表明操作栏贴近屏幕顶部，背景向上延伸入系统状态栏区域。相对的，值UIBarPositionTop表示操作栏位于当前局部内容的顶部（比如，在弹出式气泡的顶部）它不为状态栏提供背景</li>
</ul>
<h4 id="局部设置">局部设置</h4>
<ul>
<li>[self setEdgesForExtendedLayout:UIRectEdgeNone]; 设置本控制器的视图延伸范围。对本控制器视图有效果。在ios7以下ios3以上的系统，可以使用wantsFullScreenLayout属性代替。 </li>
<li>在全局设置的情况下，可以单独设置某个控制器view延伸到导航栏和状态栏下面：extendedLayoutIncludesOpaqueBars属性，默认是NO,设置为YES时，可以延伸。</li>
</ul>
<p>//////////////////////////////////////////////////6月11日更新<br>总结中case3里面，背景图片如果是半透明的，self.view还是会有延伸效果的；所以如果想阻挡它的延伸，一定要是不透明的背景图片。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="问题">问题</h3>
<hr>
<p>   最近做了个关于UINavigationController的demo，遇到一个问题，又引出更多问题，记录一下。 在ios7中，UINavigationController发生了很大的变化，特别是导航栏。<br>   先]]>
    </summary>
    
      <category term="iOS应用程序开发" scheme="http://wubinge.github.io/tags/iOS%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="iOS应用程序开发" scheme="http://wubinge.github.io/categories/iOS%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[object-c的copy机制(二)]]></title>
    <link href="http://wubinge.github.io/2015/03/24/object-c%E7%9A%84copy%E6%9C%BA%E5%88%B6-%E4%BA%8C/"/>
    <id>http://wubinge.github.io/2015/03/24/object-c的copy机制-二/</id>
    <published>2015-03-24T08:48:00.000Z</published>
    <updated>2015-04-28T06:42:58.000Z</updated>
    <content type="html"><![CDATA[<h4 id="前言">前言</h4>
<p>上篇分析了NSString的copy和retain的区别，引出对custom object copy探究，参考了一些资料，这里做讨论。</p>
<hr>
<h4 id="实现了NSCopy/NSMutableCopying的框架类">实现了NSCopy/NSMutableCopying的框架类</h4>
<p>我们都知道oc框架里面的例如NSString、NSArray等很多类的对象在需要复制的时候都可以直接调用[obj copy/mutablecopy]方法。调用copy方法时，会向NSCopying的协议方法copywithzone发消息的。作为根类的NSObject并没有实现NSCopying协议，所以他们都默认实现了NSCopying和NSMutableCopying协议，实现copywithzone和mutablecopywithzone方法。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="input"><span class="prompt">@interface NSString : NSObject &lt;NSCopying, NSMutableCopying, NSSecureCoding&gt;</span>  </span></div><div class="line">  </div><div class="line"><span class="input"><span class="prompt">@interface NSArray : NSObject &lt;NSCopying, NSMutableCopying, NSSecureCoding, NSFastEnumeration&gt;</span>  </span></div><div class="line">  </div><div class="line"><span class="variable">@interface</span> <span class="constant">NSDictionary</span> <span class="symbol">:</span> <span class="constant">NSObject</span> &lt;<span class="constant">NSCopying</span>, <span class="constant">NSMutableCopying</span>, <span class="constant">NSSecureCoding</span>, <span class="constant">NSFastEnumeration</span>&gt;</div></pre></td></tr></table></figure>

<hr>
<h4 id="自定义的对象的copy/mutablecopy">自定义的对象的copy/mutablecopy</h4>
<p>我们自定义的对象要想调用copy/mutablecopy方法，也必须手动实现NSCopying协议，实现两个方法。如果没有实现，调用copy方法会抛出异常。</p>
<p>定义一个person类：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">@interface Person : NSObject  </span></div><div class="line"><span class="comment">@property (strong,nonatomic) NSString* name;  </span></div><div class="line"><span class="comment">@property (assign,nonatomic) NSInteger age;  </span></div><div class="line"><span class="comment">@property (strong,nonatomic) NSArray* sons;  </span></div><div class="line"><span class="comment">@end  </span></div><div class="line">//<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>  </div><div class="line"><span class="comment">@implementation Person  </span></div><div class="line">  </div><div class="line"><span class="comment">@end</span></div></pre></td></tr></table></figure>

<hr>
<h4 id="使用copy方法：">使用copy方法：</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> Person* <span class="variable">p =</span> [[Person alloc] init];   </div><div class="line"><span class="number">2</span> p.<span class="variable">name =</span> @<span class="string">"张三"</span>;  </div><div class="line"><span class="number">3</span> p.<span class="variable">age =</span> <span class="number">50</span>;  </div><div class="line"><span class="number">4</span> p.<span class="variable">sons =</span> @[@<span class="string">"张小一"</span>,@<span class="string">"张小二"</span>];  </div><div class="line"><span class="number">5</span> Person* <span class="variable">copy =</span> [p copy];</div></pre></td></tr></table></figure>

<p>抛出异常：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">*** Terminating app due <span class="keyword">to</span> uncaught exception <span class="comment">'NSInvalidArgumentException', reason: '-[Person copyWithZone:]: unrecognized select  </span></div><div class="line"><span class="keyword">or</span> sent <span class="keyword">to</span> instance <span class="number">0x8b240d0</span><span class="comment">'</span></div></pre></td></tr></table></figure>

<p>无法识别的方法消息，这里因为person没有实现NSCopying协议和coypwithzone方法。接下来我为person类添加协议和方法。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">@interface Person : NSObject&lt;NSCopying,NSMutableCopying&gt;  </span></div><div class="line">...  </div><div class="line">...  </div><div class="line">...  </div><div class="line"><span class="comment">@end   </span></div><div class="line">//<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>  </div><div class="line"><span class="comment">@implementation Person </span></div><div class="line">-(id)copyWithZone:(NSZone <span class="keyword">*</span>)zone</div><div class="line">{</div><div class="line">    Person<span class="keyword">*</span> copy = [[self class] allocWithZone:zone]; //分配新的内存空间 对于self本身来说，属于深拷贝了。</div><div class="line">    copy.name = [self.name copy]; //NSString的copy，对于name，属于浅拷贝，因为都属于不可变</div><div class="line">    copy.age = self.age;   </div><div class="line">    copy.sons = [self.sons copy]; //同样浅拷贝    </div><div class="line">       </div><div class="line">    return self;   </div><div class="line">}   </div><div class="line">-(id)mutableCopyWithZone:(NSZone <span class="keyword">*</span>)zone</div><div class="line">{ </div><div class="line">    Person<span class="keyword">*</span> copy = [[self class] allocWithZone:zone];//分配新的内存空间   </div><div class="line">    copy.name = [self.name mutableCopy]; //深拷贝 不可变拷贝可变   </div><div class="line">    copy.age = self.age;   </div><div class="line">    copy.sons = [self.sons mutableCopy]; //同样深拷贝   </div><div class="line">    return copy;   </div><div class="line">}  </div><div class="line"><span class="comment">@end</span></div></pre></td></tr></table></figure>

<p>使用copy：</p>
<pre><code>Person* <span class="variable">p =</span> [[Person alloc] init];  
p.<span class="variable">name =</span> @<span class="string">"张三"</span>;  
p.<span class="variable">age =</span> <span class="number">50</span>;  
p.<span class="variable">sons =</span> @[@<span class="string">"张小一"</span>,@<span class="string">"张小二"</span>];      
Person* <span class="variable">copy =</span> [p copy]; 
</code></pre><p>打印地址：</p>
<pre><code><span class="built_in">NSLog</span>(<span class="string">@"copy addr = %p"</span>,<span class="keyword">copy</span>);
<span class="keyword">copy</span> addr = <span class="number">0x8d34750</span> 
</code></pre><p>我们看到，地址不同，copy的内存空间是新开辟的。这里要说一下，因为一般我们copy出来的Person对象，副本变动不希望影响到另一个。所以在copywithzone里面如上面那样操作，新开辟内存空间，逐个成员变量赋值；如果copy的对象不考虑互相影响的后果，则可以直接：</p>
<pre><code>(<span class="keyword">id</span>)copyWithZone:(NSZone *)zone  
{  
    <span class="keyword">return</span> <span class="keyword">self</span>;  
}
</code></pre><p>不过这样貌似没有什么意义，不如直接用：</p>
<pre><code><span class="attribute">Person* copy </span>=<span class="string"> p;</span>
</code></pre><p>Person的name和sons都属于不可变，并且调用的是copy，所以对象p和copy的这两个成员的地址应该是一样的。 我们打印出name和sons的值和地址来看一下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="type">NSLog</span>(@<span class="string">"p.sons addr = %p && copy.sons addr = %p"</span>,p.sons,copy.sons);  </div><div class="line"><span class="type">NSLog</span>(@<span class="string">"p's son addr = %p && copy's son addr = %p"</span>,[p.sons objectAtIndex:<span class="number">0</span>],[copy.sons objectAtIndex:<span class="number">0</span>]);  </div><div class="line">p.sons <span class="keyword">addr</span> = <span class="number">0x8d46410</span> && copy.sons <span class="keyword">addr</span> = <span class="number">0x8d46410</span>  </div><div class="line">p's son <span class="keyword">addr</span> = <span class="number">0x5858</span> && copy's son <span class="keyword">addr</span> = <span class="number">0x5858</span></div></pre></td></tr></table></figure>

<p>这个结果没有悬念，遵循不可变对象copy属于浅拷贝。</p>
<p>这里注意到，我专门打印出p.sons 和copy.sons的第一个元素地址来做对比，他们是一样的。NSArray是容器类型，里面的元素是在copy的时候是什么样的情况，后面详细讨论。</p>
<hr>
<h4 id="使用mutablecopy方法">使用mutablecopy方法</h4>
<p>可以看到，copywithzone和mutablecopywithzone都创建了新的内存空间，不同之处在于对成员变量的处理上。</p>
<pre><code>Person* <span class="variable">copy =</span> [p mutableCopy];
//打印地址
p.name <span class="variable">addr =</span> <span class="number">0</span>x5848 &amp;&amp; copy.name <span class="variable">addr =</span> <span class="number">0</span>x8a3db30  
p.sons <span class="variable">addr =</span> <span class="number">0</span>x8a3f8f0 &amp;&amp; copy.sons <span class="variable">addr =</span> <span class="number">0</span>x8a3f020  
p's son <span class="variable">addr =</span> <span class="number">0</span>x5858 &amp;&amp; copy's son <span class="variable">addr =</span> <span class="number">0</span>x5858  
</code></pre><p>结果是name和sons都被深拷贝，sons里面元素仍然是浅拷贝，看来NSArray的mutablecopy不会令其中的元素深拷贝。</p>
<hr>
<h4 id="容器类对象的拷贝">容器类对象的拷贝</h4>
<p>参考<a href="http://www.cnblogs.com/ydhliphonedev/archive/2012/04/27/2473927.html" target="_blank" rel="external">http://www.cnblogs.com/ydhliphonedev/archive/2012/04/27/2473927.html</a><br>对于类似NSArray、NSDictionary之类的容器元素，要想实现深拷贝，可以参考以下两种方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *array = [<span class="built_in">NSArray</span> arrayWithObjects:[<span class="built_in">NSMutableString</span> stringWithString:<span class="string">@"first"</span>],[<span class="built_in">NSString</span> stringWithString:<span class="string">@"b"</span>],<span class="string">@"c"</span>,<span class="literal">nil</span>];  </div><div class="line"><span class="number">1</span>、<span class="built_in">NSArray</span> *deepCopyArray=[[<span class="built_in">NSArray</span> alloc] initWithArray: array copyItems: <span class="literal">YES</span>];  </div><div class="line"><span class="number">2</span>、<span class="built_in">NSArray</span>* trueDeepCopyArray = [NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject: array]];</div></pre></td></tr></table></figure>

<p>打印元素地址：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSLog(<span class="variable">@"</span>array enum addr = <span class="variable">%p</span>,<span class="variable">%p</span>,<span class="variable">%p</span>\n<span class="string">",array[0],array[1],array[2]);</span></div><div class="line">   NSLog(<span class="variable">@"</span>deepCopyArray enum addr = <span class="variable">%p</span>,<span class="variable">%p</span>,<span class="variable">%p</span>\n",deepCopyArray[<span class="number">0</span>],deepCopyArray[<span class="number">1</span>],deepCopyArray[<span class="number">2</span>]);</div><div class="line">   NSLog(<span class="variable">@"</span>trueDeepCopyArray enum addr = <span class="variable">%p</span>,<span class="variable">%p</span>,<span class="variable">%p</span>\n<span class="string">",trueDeepCopyArray[0],trueDeepCopyArray[1],trueDeepCopyArray[2]);</span></div></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">array enum addr             = <span class="number">0x7f81d05ab020</span>,<span class="number">0x10958d0d0</span>,<span class="number">0x10958d0f0</span></div><div class="line">deepCopyArray enum addr     = <span class="number">0x7f81d05ab080</span>,<span class="number">0x10958d0d0</span>,<span class="number">0x10958d0f0</span></div><div class="line">trueDeepCopyArray enum addr = <span class="number">0x7f81d05abb50</span>,<span class="number">0x7f81d05abcd0</span>,<span class="number">0x7f81d05ac030</span></div></pre></td></tr></table></figure>

<p>trueDeepCopyArray是完全意义上的深拷贝，而deepCopyArray则不是，对于deepCopyArray内的不可变元素其还是指针复制。</p>
<p>或者我们自己实现深拷贝的方法。因为如果容器的某一元素是不可变的，那你复制完后该对象仍旧是不能改变的，因此只需要指针复制即可。除非你对容器内的元素重新赋值，否则指针复制即已足够。举个例子，[[array objectAtIndex:0]appendstring:@”sd”]后其他的容器内对象并不会受影响。[[array objectAtIndex:1]和[[deepCopyArray<br> objectAtIndex:1]尽管是指向同一块内存，但是我们没有办法对其进行修改——因为它是不可改变的。所以指针复制已经足够。所以这并不是完全意义上的深拷贝，但是apple的官方文档将其列为deep copy了，并添加了copy和mutablity的关系说明，故在此做一说明</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="前言">前言</h4>
<p>上篇分析了NSString的copy和retain的区别，引出对custom object copy探究，参考了一些资料，这里做讨论。</p>
<hr>
<h4 id="实现了NSCopy/NSMutableCopying的框架类">]]>
    </summary>
    
      <category term="object-c" scheme="http://wubinge.github.io/categories/object-c/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[object-c的copy机制(一)]]></title>
    <link href="http://wubinge.github.io/2015/03/24/object-c%E7%9A%84copy%E6%9C%BA%E5%88%B6-%E4%B8%80/"/>
    <id>http://wubinge.github.io/2015/03/24/object-c的copy机制-一/</id>
    <published>2015-03-24T08:28:05.000Z</published>
    <updated>2015-04-28T06:42:40.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>之前的编码中，对于NSString的property修饰，习惯性使用copy，只是粗略的知道copy属于深复制，retain/strong属于浅复制，并没有对其深究。最近需要详细了解这一块知识，在网上搜索相关内容，并且用代码验证，查看对比了内存地址，做一些总结。  </p>
<h3 id="理解">理解</h3>
<p>之前对于copy和retain/strong的区别理解是这样的：<br>copy是复制了源对象所在内存空间的数据，放入目的对象指针指向的内存空间，并且令目的对象引用计数为1，对于源对象的引用计数没有影响；源对象内容的改变不会影响到目的对象。<br>retain/strong是目的对象指针指向源对象的内存空间，源对象的引用计数+1；源对象的改变会影响到目的对象。mutablecopy返回的是可变的对象，copy返回的是不可变的对象。</p>
<h3 id="代码验证">代码验证</h3>
<p> 1、源对象为不可变 NSString</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span>*str = <span class="string">@"test"</span>;</div><div class="line"><span class="built_in">NSString</span>* retainStr = [str retain];</div><div class="line"><span class="built_in">NSString</span>* copyStr = [str <span class="keyword">copy</span>];</div><div class="line"><span class="built_in">NSMutableString</span>* mcopyStr = [str mutableCopy];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"str addr = %p"</span>,str);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"retainStr addr = %p"</span>,retainStr);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"copyStr addr = %p"</span>,copyStr);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"mcopyStr addr = %p"</span>,mcopyStr);</div></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">str <span class="keyword">addr</span> = <span class="number">0x4598</span></div><div class="line">retainStr <span class="keyword">addr</span> = <span class="number">0x4598</span></div><div class="line">copyStr <span class="keyword">addr</span> = <span class="number">0x4598</span></div><div class="line">mcopyStr <span class="keyword">addr</span> = <span class="number">0x8caf630</span></div></pre></td></tr></table></figure>

<ul>
<li>retain的对象毫无悬念，还是源对象的内存地址；</li>
<li>copy的对象和我原来想的不一样，竟然和retain一样，也是源对象地址；这意味者并没有对源对象内容进行复制，而只是复制了指针而已。如此看来copy方法并不一定会复制源对象的内容。之所以复制，肯定是因为两个版本有所不同。而这里源对象是NSString不可变的，copy返回的也是不可变的，既然都不可变，那么这里的副本就没有多大意义存在，就如同使用字符串常量，系统会为我们优化，声明多个字符串，都是不可变且内容相同，那么系统就只申请一块内存，这个道理是一样的。指向一块内存就可以了，所以这里的copy和retain的作用是一样的。</li>
<li>mutablecopy的对象地址和源对象地址不同，说明重新开辟了内存，复制了一个副本。因为mutablecopy返回的对象是可变的，它的变动会影响到源对象，所以需要拷贝一份。</li>
</ul>
<p>2、源对象为可变的NSMutableString</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableString</span>* str = [<span class="built_in">NSMutableString</span> stringWithString:<span class="string">@"test"</span>];</div><div class="line"><span class="built_in">NSString</span>* retainStr = [str retain];</div><div class="line"><span class="built_in">NSString</span>* copyStr = [str <span class="keyword">copy</span>];</div><div class="line"><span class="built_in">NSMutableString</span>* mcopyStr = [str mutableCopy];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"str addr = %p"</span>,str);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"retainStr addr = %p"</span>,retainStr);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"copyStr addr = %p"</span>,copyStr);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"mcopyStr addr = %p"</span>,mcopyStr);</div></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">str</span> addr = <span class="number">0x8b7a130</span></div><div class="line">retainStr addr = <span class="number">0x8b7a130</span></div><div class="line">copyStr addr = <span class="number">0x8b751d0</span></div><div class="line">mcopyStr addr = <span class="number">0x8b7a170</span></div></pre></td></tr></table></figure>

<ul>
<li>retain仍然和目的对象地址相同；</li>
<li>copy的地址和目的对象地址不相同，是因为源对象是可变的，目的对象不可变，当然需要两个不同的版本；</li>
<li>mutablecopy形成了一个新的副本。因为两个对象的改变会影响到对方，所以需要两个版本。</li>
</ul>
<h3 id="结论">结论</h3>
<ul>
<li>对于copy来说，如果源对象是不可变的，那么是浅拷贝，没有必要深拷贝；如果源对象可变，为了安全性，深拷贝，生成副本。</li>
<li>对于mutablecopy来说，不管源对象是否可变，都是深拷贝。<br>因此我们在设置property的copy属性时，是在源对象为可变的情况下,如果希望对象跟着源对象的值变化，那么就是用retain；如果希望对象保持独立的值，那就使用copy。</li>
</ul>
<p>上面讨论的是NSString相关的retain/copy/mutablecopy，在oc里面所有实现了NSCopying和NSMutableCopying协议的类，都具有copy和mutablecopy这两个方法。<br>那么自定义对象的copy特性，它们是什么样的，下一篇进行探究。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2>
<p>之前的编码中，对于NSString的property修饰，习惯性使用copy，只是粗略的知道copy属于深复制，retain/strong属于浅复制，并没有对其深究。最近需要详细了解这一块知识，在网上搜索相关内容，并且用代码验证，查看]]>
    </summary>
    
      <category term="object-c" scheme="http://wubinge.github.io/categories/object-c/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自己动手写flv文件]]></title>
    <link href="http://wubinge.github.io/2015/03/23/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99flv%E6%96%87%E4%BB%B6/"/>
    <id>http://wubinge.github.io/2015/03/23/自己动手写flv文件/</id>
    <published>2015-03-23T11:24:28.000Z</published>
    <updated>2015-06-05T09:14:12.000Z</updated>
    <content type="html"><![CDATA[<p>项目需要使用ffmpeg来实现flv格式的编解码功能。ffmpeg对编解码大致分两部分来实现：数据编码和文件编码，直接调用相关api就可以实现。然而不够灵活，需要自己定制flv格式，于是就把文件编码这一部分自己来做，加入自己的东西。数据的编码直接使用ffmpeg的api。解码的时候根据由自己来分析格式，抽取纯音频数据，进行解码。</p>
<p>首先需要对flv的格式做一个了解，这块网上文章很多，也很详细。</p>
<p>flv文件分为header区和tag区。header区都是固定的9bytes,接着是为了兼容格式的previous size 4bytes。后面就是tag区。一般第一个tag是标示为0x12的脚本tag，包含了一些音频信息，例如时长，文件大小等。也有的没有脚本tag，那么播放器就会遍历文件寻找这些信息。web版flv由于编码过程不够规范，所以很多没有脚本tag，自然得不到tag信息，但是这个需求是听录音，mp3和flv一起播放，而mp3的长度是可以得到的；然而手机生成的录音就需要打上长度信息.<br>header区和脚本tag可以先作为文件头写入flv文件，脚本tag可以根据自己的需求来定制。只要符合播放器的解码规则，不要视为错误文件就可以。</p>
<p>每个tag分为header和data两个区。tag header 固定的是11个字节，tag类型(1byte)、data大小(3bytes)、timestamp(3bytes)、exTimestamp扩展时间戳，作为时间戳的高位(1byte)和stramid(3bytes恒为0).。后面紧跟着是tag data ，开头1byte标示 出该tag data的一些音频信息，例如编码类型、通道数等。在tag data后面还有一个4bytes的区域表示该tag的size。据此可以看出，每个tag的size是不固定的，取决于tag data的大小。但是tag的header和data第一个byte以及后面的previous的大小和值是固定的。除了header中的data大小、timestamp和previous size的值。</p>
<p>下面就是纯音频数据的编码了。我们的原始数据都是未经压缩的pcm数据，来源可以是声卡，也可以是文件和网络流。拿到的pcm数据，要先进行分割，确定一个包的大小。先找到所使用的编码器的压缩比是多少，这个一般是常数。在ffmpeg的decoder实例中可以找到。据此计算出编码后的数据的大小，为方便读取，尽量把包分割成相同大小。然后把这个值+1写进tagheader的datasize区，当然previoussize的大小也可以确定了。至于时间戳，知道采样率，那么也就很容易计算出来了。例如压缩比是8：1。原始数据512编码之后就是64，那么就65就是tagdata的大小，不要忘了前面的1byte的音频信息。</p>
<p>   要注意一点，在实际的编码中，可能会出现缓存不足导致丢包的现象，这时候会出现时间戳错误，导致不同步。</p>
<p>   本来打算按照脚本tag的标准格式写入信息，但是觉得太麻烦。所以tag头按照标准，内容就用4bytes存储samples。当然，前面最好加一个校验标志。反正是自己来读取。其他播放器无视就可以，只要脚本tag头的size写对就可以。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>项目需要使用ffmpeg来实现flv格式的编解码功能。ffmpeg对编解码大致分两部分来实现：数据编码和文件编码，直接调用相关api就可以实现。然而不够灵活，需要自己定制flv格式，于是就把文件编码这一部分自己来做，加入自己的东西。数据的编码直接使用ffmpeg的api。解]]>
    </summary>
    
      <category term="音视频开发" scheme="http://wubinge.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[搭建个人博客]]></title>
    <link href="http://wubinge.github.io/2015/03/18/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://wubinge.github.io/2015/03/18/搭建个人博客/</id>
    <published>2015-03-18T11:51:58.000Z</published>
    <updated>2015-05-14T08:59:10.000Z</updated>
    <content type="html"><![CDATA[<h3 id="前言">前言</h3>
<hr>
<p>之前在csdn上写过博文，觉得它的编辑框使用起来毫无沉浸感，可控性也很差。于是希望搭建独立的博客。<br>在网上搜索之后，确定使用hexo博客生成框架+github page免费空间的方式来创建博客系统。<br>很喜欢markdown的语法，配合mou编辑器，写起来很有沉浸感。简单记录一下搭建过程。</p>
<h3 id="配置环境">配置环境</h3>
<hr>
<p>hexo基于node.js，那么就先安装node.js。使用Homebrew安装:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew <span class="operator"><span class="keyword">install</span> node</span></div></pre></td></tr></table></figure>

<p>node自带npm,查看安装结果:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$:</span>node -v</div><div class="line">v<span class="number">0</span>.<span class="number">10.36</span></div><div class="line"><span class="variable">$:</span>npm -v</div><div class="line"><span class="number">2.6</span>.<span class="number">1</span></div></pre></td></tr></table></figure>

<h3 id="安装hexo">安装hexo</h3>
<p>使用npm安装：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$:</span>npm install hexo -g</div></pre></td></tr></table></figure>

<p>初始化，folder为指定的目录</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo init <span class="tag">&lt;<span class="title">folder</span>&gt;</span></div></pre></td></tr></table></figure>

<p>进入folder目录内,生成静态文件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> floder</div><div class="line">hexo generate/g</div></pre></td></tr></table></figure>

<p>本地启动预览</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo server</div><div class="line">info] Hexo is running <span class="keyword">at</span> <span class="keyword">http</span>://localhost:<span class="number">4000</span>/. Press Ctrl+C <span class="built_in">to</span> stop.</div></pre></td></tr></table></figure>

<p>在浏览器输入<a href="http://localhost:4000/即可看到博客的预览效果。" target="_blank" rel="external">http://localhost:4000/即可看到博客的预览效果。</a></p>
<h3 id="发布到github">发布到github</h3>
<p>把我们的博客发布到github的空间。执行以下步骤：</p>
<ul>
<li>在github创建新的repository,名为username.github.io,username必须是github的用户名。</li>
<li>编辑hexo的_conig.yml的Deployment如下  </li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  <span class="built_in">type</span>: github  </div><div class="line">  repository: git@github.com:username/username.github.<span class="built_in">io</span>.git        </div><div class="line">  branch: master</div></pre></td></tr></table></figure>

<ul>
<li>hexo d -g 发布到github</li>
</ul>
<h3 id="添加多说评论系统">添加多说评论系统</h3>
<p>默认的评论系统是disqus，换成国内的多说评论系统。<br>1、登录多说，创建多说shorname。所谓shortname就是在多说后台设置的域名前缀。比如xxxx.duoshuo.com，那么short-name就是xxxx。<br>2、在_config.yml中添加多说的配置：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">duoshuo_shortname</span>: <span class="string">你站点的short_name</span></div></pre></td></tr></table></figure>


<p>3、修改themes\landscape\layout_partial\article.ejs模板 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="vbscript">&lt;% <span class="keyword">if</span> (!index && post.comments && config.disqus_shortname){ %&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">section</span> <span class="attribute">id</span>=<span class="value">"comments"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"disqus_thread"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="title">noscript</span>&gt;</span>Please enable JavaScript to view the <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"//disqus.com/?ref_noscript"</span>&gt;</span>comments powered by Disqus.<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">noscript</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="title">section</span>&gt;</span></div><div class="line">  <span class="vbscript">&lt;% } %&gt;</span></div></pre></td></tr></table></figure>

<p>改为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="vbscript">&lt;% <span class="keyword">if</span> (!index && post.comments && config.duoshuo_shortname){ %&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="title">section</span> <span class="attribute">id</span>=<span class="value">"comments"</span>&gt;</span></div><div class="line">   <span class="comment">&lt;!-- 多说评论框 start --&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"ds-thread"</span> <span class="attribute">data-thread-key</span>=<span class="value">"&lt;%= post.layout %&gt;-&lt;%= post.slug %&gt;"</span> <span class="attribute">data-title</span>=<span class="value">"&lt;%= post.title %&gt;"</span> <span class="attribute">data-url</span>=<span class="value">"&lt;%= page.permalink %&gt;"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></div><div class="line">   <span class="comment">&lt;!-- 多说评论框 end --&gt;</span></div><div class="line">   <span class="comment">&lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">   <span class="keyword">var</span> duoshuoQuery = {short_name:<span class="string">'&lt;%= config.duoshuo_shortname %&gt;'</span>};</div><div class="line">     (<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">       <span class="keyword">var</span> ds = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</div><div class="line">       ds.type = <span class="string">'text/javascript'</span>;ds.async = <span class="literal">true</span>;</div><div class="line">       ds.src = (<span class="built_in">document</span>.location.protocol == <span class="string">'https:'</span> ? <span class="string">'https:'</span> : <span class="string">'http:'</span>) + <span class="string">'//static.duoshuo.com/embed.js'</span>;</div><div class="line">       ds.charset = <span class="string">'UTF-8'</span>;</div><div class="line">       (<span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>] </div><div class="line">        || <span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>]).appendChild(ds);</div><div class="line">     })();</div><div class="line">     <span class="tag">&lt;/<span class="title">script</span>&gt;</span></div><div class="line">   <span class="comment">&lt;!-- 多说公共JS代码 end --&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="title">section</span>&gt;</span></div><div class="line"> <span class="vbscript">&lt;% } %&gt;</span></div></pre></td></tr></table></figure>

<p>摘自<a href="http://dev.duoshuo.com/threads/541d3b2b40b5abcd2e4df0e9" target="_blank" rel="external">多说教程</a></p>
<h3 id="使用jiaThis分享组件">使用jiaThis分享组件</h3>
<p>去除默认分享按钮：<br>themes\landscape\layout_partial\article.ejs中注释掉：  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;a <span class="variable">data-url=</span><span class="string">"&lt;%- post.permalink %&gt;"</span> <span class="variable">data-id=</span><span class="string">"&lt;%= post._id %&gt;"</span> <span class="variable">class=</span><span class="string">"article-share-link"</span>&gt;Share&lt;/a&gt;</div></pre></td></tr></table></figure>

<p>在想要添加jiaThis的位置放置jiaThis的代码。<br><a href="http://www.jiathis.com/getcode/icon/?style=32x32&amp;btn=qzone,tsina,tqq,weixin,renren,jicon&amp;codestyle=standard&amp;showshares=true" target="_blank" rel="external">这里</a>有更详细的教程。</p>
<h3 id="配置侧边栏">配置侧边栏</h3>
<p>博客右边的侧边栏内容可以根据自己的需求配置，下面添加aboutme工具栏。<br>在themes/landscape/_config.yml的widget下添加- aboutme</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">widget<span class="variable">s:</span></div><div class="line">- aboutme</div></pre></td></tr></table></figure>

<p>在themes/landscape/layout/_widget目录下创建aboutme.ejs。对aboutme.ejs编辑过的内容就会显示在右侧边栏。<br>对于不需要显示的工具，在themes/landscape/_config.yml中注释掉对应的名字即可：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">widgets:</div><div class="line">- category</div><div class="line"><span class="preprocessor">#- tag</span></div><div class="line"><span class="preprocessor">#- tagcloud</span></div><div class="line"><span class="preprocessor">#- archive</span></div><div class="line"><span class="preprocessor">#- recent_posts</span></div><div class="line">- aboutme</div></pre></td></tr></table></figure>

<p>值得注意的是，通过修改themes/landscape/layout放置的ejs模板文件可以对页面的元素内容做增减；网站对应的布局样式和资源文件放置在themes/landscape/source/css中，可以修改页面内容的颜色、尺寸和图片资源等。</p>
<h3 id="安装过程遇到的问题">安装过程遇到的问题</h3>
<h6 id="1、执行npm_install_hexo_-g后出现：">1、执行npm install hexo -g后出现：</h6>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">npm</span> WARN locking <span class="attribute">Error</span>: EACCES, open <span class="string">'/Users/imac/.npm/_locks/</span></div><div class="line">hexo-89ff29e8d72588ea.lock.STALE'</div><div class="line"><span class="built_in">npm</span> WARN locking  <span class="regexp">/Users/imac/</span>.<span class="built_in">npm</span><span class="regexp">/_locks/hexo-89ff29e8d72588ea.lock failed { [Error: EACCES, open '/Users/imac/</span>.<span class="built_in">npm</span>/_locks/hexo-<span class="number">89</span>ff29e8d72588ea.lock.STALE<span class="string">']</span></div><div class="line">npm WARN locking   errno: 3,</div><div class="line">npm WARN locking   code: 'EACCES<span class="string">',</span></div><div class="line">npm WARN locking   path: '<span class="regexp">/Users/imac/</span>.<span class="built_in">npm</span>/_locks/hexo-<span class="number">89</span>ff29e8d72588ea.lock.STALE<span class="string">' }</span></div><div class="line">npm ERR! Darwin 14.0.0</div><div class="line">npm ERR! argv "node" "/usr/local/bin/npm" "install" "hexo@2.8.3" "-g"</div><div class="line">npm ERR! node v0.10.35</div><div class="line">npm ERR! npm  v2.1.18</div><div class="line"></div><div class="line">npm ERR! Attempt to unlock /usr/local/Cellar/node/0.10.35_2/libexec/npm/lib/node_modules/hexo, which hasn't been locked</div><div class="line"><span class="built_in">npm</span> ERR! </div><div class="line"><span class="built_in">npm</span> ERR! If you need help, you may report <span class="keyword">this</span> error <span class="attribute">at</span>:</div><div class="line"><span class="built_in">npm</span> ERR!     &lt;<span class="attribute">http</span>:<span class="regexp">//gi</span>thub.com/<span class="built_in">npm</span>/<span class="built_in">npm</span>/issues&gt;</div><div class="line"><span class="built_in">npm</span> ERR! Please include the following file <span class="reserved">with</span> any support <span class="attribute">request</span>:</div><div class="line"><span class="built_in">npm</span> ERR!     /Users/imac/<span class="built_in">npm</span>-debug.log</div></pre></td></tr></table></figure>

<p>原因是当前用户不具有.npm和/usr/local的使用权限,修改它们的拥有者:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$:</span>sudo <span class="keyword">chown</span> -R <span class="string">`whoami`</span> .npm</div><div class="line"><span class="variable">$:</span>sudo <span class="keyword">chown</span> -R <span class="string">`whoami`</span> .npm /usr/<span class="keyword">local</span>/</div></pre></td></tr></table></figure>

<p>参考:<a href="https://github.com/npm/npm/issues/4815" target="_blank" rel="external">https://github.com/npm/npm/issues/4815</a></p>
<h6 id="2、node_gyp_rebuild卡住">2、node_gyp rebuild卡住</h6>
<p>在初始化hexo时会卡到node_gyp rebuild过程,等待很久没有反应。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fsevents@<span class="number">0.2</span>.<span class="number">0</span> install <span class="regexp">/usr/</span>local<span class="regexp">/Cellar/</span>node<span class="regexp">/0.10.35_2/</span>libexec<span class="regexp">/npm/</span>lib<span class="regexp">/node_modules/</span>hexo<span class="regexp">/node_modules/</span>chokidar<span class="regexp">/node_modules/</span>fsevents node-gyp rebuild</div></pre></td></tr></table></figure>

<p>node_gyp的编译需要python和编译工具：</p>
<ul>
<li>python (v2.7 recommended, v3.x.x is not supported)</li>
<li>make</li>
<li>A proper C/C++ compiler toolchain, like GCC</li>
</ul>
<p>如果以上都已经安装则可能是 NodeJs 源码缺失的原因。<br>node-gyp 编译时候需要 NodeJs 源码来提供头文件，所以它会先尝试下载 NodeJs 源码，由于国外CDN的原因,有时候下载 NodeJs 非常慢的。<br>那么就自己用迅雷等下载工具下载对应版本的nodejs源码,然后提取给node_gyp.<br>切记对应的node版本号。我是直接查看本地安装的node版本号下载对应node源码。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor"># wget http://nodejs.org/dist/v0.10.33/node-v0.10.33.tar.gz</span></div><div class="line"><span class="preprocessor"># 假设源码已经下载好了.</span></div><div class="line">tar zxf node-v0<span class="number">.10</span><span class="number">.33</span>.tar.gz -C ~/.node-gyp</div><div class="line">mv ~/.node-gyp/node-v0<span class="number">.10</span><span class="number">.33</span> ~/.node-gyp/<span class="number">0.10</span><span class="number">.33</span></div><div class="line">printf <span class="string">"9\n"</span>&gt;~/.node-gyp/<span class="number">0.10</span><span class="number">.33</span>/installVersion</div></pre></td></tr></table></figure>

<p>注意，不同操作系统下和编译不同的 package 时候 node-gyp 需要的源码版本有可能是不一样的，installVersion 也有可能不一样。推荐先检查一下 node-gyp 的输出日志来确定下载哪一个文件。</p>
<p>另外还可以使用 npm install —loglevel verbose 查看安装时候的详细日志，来确定需要下载的 Nodejs 源码地址。<br>参考:<a href="https://breeswish.org/blog/2014/11/14/node-gyp-rebuild-freeze/" target="_blank" rel="external">https://breeswish.org/blog/2014/11/14/node-gyp-rebuild-freeze/</a></p>
<h6 id="3、3-0版本降级到2-8-3要做的">3、3.0版本降级到2.8.3要做的</h6>
<ul>
<li>备份source、_config.yml和themes文件夹。</li>
<li>卸载高版本插件，安装低版本插件</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">npm uninstall hexo-<span class="keyword">renderer</span>-ejs hexo-<span class="keyword">renderer</span>-marked hexo-<span class="keyword">renderer</span>-stylus</div></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">npm install hexo-<span class="keyword">renderer</span>-ejs<span class="variable">@0</span><span class="number">.1</span><span class="number">.0</span> hexo-<span class="keyword">renderer</span>-marked<span class="variable">@0</span><span class="number">.1</span><span class="number">.0</span> hexo-<span class="keyword">renderer</span>-stylus<span class="variable">@0</span><span class="number">.1</span><span class="number">.0</span> hexo-generator-feed<span class="variable">@0</span><span class="number">.2</span><span class="number">.1</span> hexo-generator-sitemap<span class="variable">@0</span><span class="number">.2</span><span class="number">.0</span></div></pre></td></tr></table></figure>

<p>参考:<a href="http://sandylaw.tk/2015/03/07/hexo3to2/" target="_blank" rel="external">http://sandylaw.tk/2015/03/07/hexo3to2/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="前言">前言</h3>
<hr>
<p>之前在csdn上写过博文，觉得它的编辑框使用起来毫无沉浸感，可控性也很差。于是希望搭建独立的博客。<br>在网上搜索之后，确定使用hexo博客生成框架+github page免费空间的方式来创建博客系统。<br>很喜欢mar]]>
    </summary>
    
      <category term="标签" scheme="http://wubinge.github.io/tags/%E6%A0%87%E7%AD%BE/"/>
    
      <category term="工具方法" scheme="http://wubinge.github.io/categories/%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
</feed>
